#ifndef CUP_STRUTILS_H
#define CUP_STRUTILS_H

#include <stdint.h>
#include <stdio.h>

// HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
// All strings are assumed to be '\0' terminated
// HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH

/* 
	Split string into multiple substrings whenever a delimiter is found.

	[src] = string to be split
	[delim] = string containing all delimiters
	[str_count] = stores number of substrings generated (OUT)

	Returns an array containing all substrings found. 
	If no delimiter was found, the array contains a copy of the source string.
*/
char** cup_str_split(char* src, char* delim, size_t* strCount);

/* 
	Split string into multiple substrings whenever an exact match
	of the delimiter substring is found.

	[src] = string to be split
	[substr] = string containing the delimiter substring
	[str_count] = stores number of substrings generated (OUT)

	Returns an array containing all substrings found. 
	If no match was found, the array contains a copy of the source string.
*/
char** cup_str_split_substr(char* src, char* substr, size_t* str_count);

/*
	Free string array generated by cup_str_split and cup_str_split_substr.

	[arr] = array of strings to be freed
	[len] = length of the array

	This function does not return a value.
*/
void cup_free_string_array(char** arr, size_t len);

/*
	Count how many times a character was found in a string.

	[src] = string on which to search
	[ch] = the target character

	Returns the number of times the character was found within the source string.
*/
size_t cup_count_char(char* src, char ch);

/*
	Count how many times a substring appears in a string.

	[src] = string on which to search
	[substr] = the target substring

	Returns the number of times the substring was found within the source string.
*/
size_t cup_count_substr(char* src, char* substr);

/*
	Generate a subtring from a string.

	[src] = source string to copy from
	[start] = position (index) from which to start copying
	[end] = position (index) on which to stop copying

	Returns the generated substring.
	If end is greater than the source's length, the substring ends at the source string's end.
	If start or end values are invalid (i.e., negative or end < start), returns NULL.	
*/
char* cup_substr(char* src, size_t start, size_t end);

/*
	Create a copy of a string.

	[src] = string to be copied

	Returns the created copy.
	If memory allocation fails, returns NULL.
*/
char* cup_str_dup(char* src);

/*
	Transforms string to uppercase.

	[src] = string to be transformed

	This function does not return a value.
*/
void cup_to_upper(char* src);

/*
 	Reads the entire file.
  	
  	[in] = file descriptor of the file to be read
 
  	Returns a string with the file content.
	If memory allocation fails, returns NULL.
*/
char* cup_read_file(FILE* in);

#endif

#ifdef CUP_STRUTILS_IMPLEMENTATION

#include <string.h>
#include <stdlib.h>

char** cup_str_split(char* src, char* delim, size_t* str_count)
{
	*str_count = 0;
	char** strings = NULL;

	if (!src)	return strings;
	if (!delim)	return strings;

	// Return if no delimiters found
	if (!strpbrk(src, delim)) {
		strings = malloc(sizeof(char*));
		strings[0] = cup_str_dup(src);
		*str_count = 1;
		return strings;
	}

	size_t src_len = strlen(src);
	size_t delim_len = strlen(delim);
	
	// Count delimiter occurrences	
	size_t count = 0;
	for (size_t i = 0; i < src_len; ++i) {
		for (size_t j = 0; j < delim_len; ++j) {
			if (src[i] == delim[j]) {
				count++;
				break;
			}
		}
	}

	// Allocate correct number of substrings
	strings = malloc((count + 1) * sizeof(char*));
	*str_count = count + 1;

	// Find and create substrings
	for (size_t i = 0; i <= count; ++i) {
		size_t new_str_len = strcspn(src, delim);
		strings[i] = cup_substr(src, 0, new_str_len);
		src += new_str_len + 1;
	}

	return strings;
}

char** cup_str_split_substr(char* src, char* substr, size_t* str_count)
{
	*str_count = 0;
	char** strings = NULL;

	// Guard clauses
	if (!src) 		return strings;
	if (!substr)	return strings;
	

	// Return if no substring was found
	if (!strstr(src, substr)) {
		strings = malloc(sizeof(char*));
		strings[0] = cup_str_dup(src);
		*str_count = 1;
		return strings;
	}

	size_t substr_len = strlen(substr);

	// Count substring occurrences	
	size_t count = 0;
	char* ptr = src;
	while (*ptr) {
		char* c = strstr(ptr, substr);
		if (c) {
			ptr = c + substr_len;
			count++;
		}
		else {
			ptr++;
		}
	}

	// Allocate correct number of substrings
	strings = malloc((count + 1) * sizeof(char*));
	*str_count = count + 1;

	// Find and create substrings
	for (size_t i = 0; i <= count; ++i) {
		size_t new_str_len = strstr(src, substr) - src;
		strings[i] = cup_substr(src, 0, new_str_len);
		src += new_str_len + substr_len;
	}

	return strings;
}

void cup_free_string_array(char** arr, size_t len)
{
	if (!arr) return;

	for (size_t i = 0; i < len; ++i)
		if (arr[i]) free(arr[i]);
	free(arr);
}

size_t cup_count_char(char* src, char ch) 
{
	if (!src) return 0;
	
	size_t count = 0;
	size_t length = strlen(src);
	for (size_t i = 0; i < length; ++i)
		if (src[i] == ch) count++;

	return count;
}

size_t cup_count_substr(char* src, char* substr)
{
	if (!src)		return 0;
	if (!substr)	return 0;

	size_t src_len = strlen(src);
	size_t substr_len = strlen(substr);
	if (!src_len) 				return 0;
	if (!substr_len) 			return 0;
	if (src_len < substr_len) 	return 0;

	size_t count = 0;
	while ((src = strstr(src, substr)))
		count++;

	return count;
}

char* cup_substr(char* src, size_t start, size_t end) 
{
	// Gaurd clauses
	if (!src) 			return NULL;
	if (start > end) 	return NULL;

	// Allocate enough memory
	size_t len = strlen(src);
	if (end > len) end = len;
	
	size_t char_count = end - start;
	char* new_str = malloc(sizeof(char) * (char_count + 1));
	if (!new_str) return NULL;

	// Copy string
	memcpy((void*)new_str, (void*)(src + start), char_count);
	new_str[char_count] = '\0';

	return new_str;
}

char* cup_str_dup(char* src)
{
	if (!src) return NULL;

	size_t len = strlen(src) + 1;
	char* copy = malloc(len * sizeof(char));
	if (copy) 
		memcpy ((void*) copy, (void*) src, len);

	return copy;
}

void cup_to_upper(char* src)
{
	if (!src) return;

	size_t len = strlen(src);
	for (size_t i = 0; i < len; ++i) {
		char ch = src[i];
		if (ch > 0x60 && ch < 0x7B)
			src[i] = ch - 0x20;
	}
}

char* cup_read_file(FILE* in)
{
	fseek(in, 0, SEEK_END);
	int size = ftell(in);
	fseek(in, 0, SEEK_SET);

	char* content = malloc(size + 1);
	if (!content) return NULL;

	fread(content, size, 1, in);
	content[size] = 0;

	return content;
}

#endif
